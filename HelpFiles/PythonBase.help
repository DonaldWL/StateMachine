This is a abstract class that you can use to create a state machine in 
python.  The tables can be a little bit complicated, so I would recommend
that you consider using the SMS library and the TPL libraries to create
an application that will allow you to generate the end user state machine.
You can also find a StateMachineGenerator program that uses this.  It is 
with all the applications.

If you decide to modify the abstract 'CStateMachine' class, be very careful,
it does not take much to break this code.

  CStateMachine(TraceFile = None, FriendlyTrace = False)
  
    TraceFile
      Is any instance of any class that has a method called 'write'.  It should
      behave just like the write for 'sys.stdout'.  It should not add a new line.
      If None, default, the tracing will not occur.  The method that outputs the
      trace data can be overriding to handle how you wish it to work.
      
    FriendlyTrace
      If true then a nicer output will be done on trace, but it will take up a lot
      more room in your log file or on the screen.  By default this is set to False.
      If set to false it works better for log files.  One line is all that is put out
      for each trace.  If True many lines are written out for each trace.
      
  CodeBlockName = GetCodeBlockName(CBIndex)
    This method must be overriding to get the code block name.
    
    CBIndex
      Is the index into the CodeBlockNames table.
      
  StateName = GetStateName(SNIndex)
    This method must be overriding to get the name of the state.
    
    SNIndex
      Is the index into the StateNames table.
       
  ExitCode = Run()
    Runs the state machine.  The end state (if one) returns a value from this method.
    Many state machines do not have an end state.
    
  TraceStatesWithOutPrev(StateTableEntry, State, RStateValue, PrevStateTableEntry,
                         PrevState, PrevRStateValue)
    This is used to trace the state machine.  It has two modes of operations.  FriendlyTrace
    and Non-FriendlyTrace.  See the argument FriendlyTrace when you create the state machine
    instance.  For logging its best to have this set to Non-FriendlyTrace.  This does not
    output the Previous state information along with the current state.  This is the preferred
    method.  It keeps the log file smaller.  This is the default trace method to use.  The
    variable self.TraceFileMethod is set to this method by default.  You can write your
    own Trace method with this interface and in your init code set self.TraceFileMethod to
    your method.  
    
      StateTableEntry
        See the definition of the tables.
      
      State
        The name of the state
        
      RStateValue
        The states RStateValue
        
      PrevStateTableEntry
        If None then no previous state.  See the definition of the tables.
        
      PrevState
        If PrevStateTableEntry is not None then the name of the previous state.
      
      PrevRStateValue
        If PrevStateTableEntry is not None then the RStateValue from the previous state.

  TraceStatesWithPrev(StateTableEntry, State, RStateValue, PrevStateTableEntry,
                      PrevState, PrevRStateValue)
    This is used to trace the state machine.  It has two modes of operations.  FriendlyTrace
    and Non-FriendlyTrace.  See the argument FriendlyTrace when you create the state machine
    instance.  For logging its best to have this set to Non-FriendlyTrace.  This does output
    the Previous state information along with the current state.  It makes the log file bigger.
    This is not the default.  See 'TraceStatesWithOutPrev'.   You can write your
    own Trace method with this interface and in your init code set self.TraceFileMethod to
    your method.  
        
      StateTableEntry
        See the definition of the tables.
      
      State
        The name of the state
        
      RStateValue
        The states RStateValue
        
      PrevStateTableEntry
        If None then no previous state.  See the definition of the tables.
        
      PrevState
        If PrevStateTableEntry is not None then the name of the previous state.
      
      PrevRStateValue
        If PrevStateTableEntry is not None then the RStateValue from the previous state.

  CodeBlockTable
    This table contains all the code blocks to be executed by each state.  Each code block
    has one entry in the tuple.  Thus, this is a tuple of tuples.  The first entry is the
    first code block and so on.  To access a code block you index into this table.  We use
    the CodeBlockEntryDef to define each entry.  We shortened the name to CBEntryDef.  Below
    is an example of an entry.  The CBB is an enum class for each codeblock name.  This is
    done to make it a bit more readable.  We then have the next entry that is the code.  It
    is compiled.  If you have never used the python 'compile' statement I recommend you review
    this before using this state machine.  The first param is the code to compile, then
    the module name and then how we will invoke the code.  For how this all looks see the
    example.
  
      CBEntryDef(CBB.CodeBlock2, compile(self.CodeBlock2, MFName, "exec"))

  StateTable
    This table contains all the states and all the transition for each state.  This table can
    be very hard to create by hand.  You should consider using the SMS and TPL libraries to
    create your state machine.
    
    This table is a tuple of tuples just like CodeBlockTable.  Each entry is a state and the
    states transition information.  Each entry is based on StateTableEntryDef, but this has 
    been renames to STEntryDef to make the line shorter.
    
    The first entry is the code block to execute.  This is a index into the CodeBlockTable.
    Each state always has a code block the it relates to.  The same code block can be used
    by more than one state.
    
    The next entry is a tuple of state transitions.  This is what the StateRValue is used
    for.  The StateRValue is the index into the list of states.  Thus if StateRValue is set
    to 0 then STT.StartState would be executed and so on.  The next item in this tuple is
    the Otherwise.  If StateRValue is not within the range of the state transitions then
    use Otherwise.  If a state does not have an otherwise to use it will be set to -1.
    
    The STT is a enum class to make the entry easer to read.  See the example on how this
    looks and works.
    
      STEntryDef(CBB.CodeBlock1, (STT.StartState, STT.State1, STT.State2), -1)  
  
  EXAMPLE1
    This example shows how you only place your state code within a string.  It will be
    compiled.  This works for simple code blocks, but I have come across some very
    strange bugs in the python 'compile' statement.  Thus, I recommend that you use
    EXAMPLE2 style instead.
  
    import random # pylint: disable=unused-import
    import sys
    import os
    from enum import IntEnum
    
    from Libs.Base.CodeTimer import (CCodeTimer, CCaptureTimer)
    from Libs.Base.CreationInfo import CCreationInfo
    from Libs.StateMachine import (CodeBlockEntryDef as CBEntryDef,   # pylint: disable=unused-import
                                   CStateMachine,
                                   StateTableEntryDef as STEntryDef,
                                   StateMachineError)
    
    class CStateMachinePy(CStateMachine):
    
      def __init__(self, TraceFile = None, FriendlyTrace = False):
        CStateMachine.__init__(self, TraceFile, FriendlyTrace)
        self.StateRValue = -1
        
          # You must capture the globals and locals for the exec
          # If you wish to control the exec you can set this to what you
          # wish the block of code to have access to.
        self.Globals = globals()
        self.Locals = locals()    
    
          # Get our module name    
        MFName = os.path.basename(CCreationInfo().CreationFile)
        
        class CBB(IntEnum):
          CodeBlock1 = 0
          CodeBlock2 = 1
          CodeBlock3 = 2
          EndMachine = 3
    
        self.CodeBlockTable = (CBEntryDef(CBB.CodeBlock1, compile(self.CodeBlock1, MFName, "exec")),
                               CBEntryDef(CBB.CodeBlock2, compile(self.CodeBlock2, MFName, "exec")),
                               CBEntryDef(CBB.CodeBlock3, compile(self.CodeBlock3, MFName, "exec")),
                               CBEntryDef(CBB.EndMachine, compile(self.EndMachine, MFName, "exec")))
        self.CB = CBB # Used to allow access outside of __init__
        
        self.StartState = 1
        self.EndState = 0
        class STT(IntEnum):
          EndState = 0
          StartState = 1
          State1 = 2
          State2 = 3
          State3 = 4
    
        self.StateTable = (STEntryDef(CBB.EndMachine, (STT.EndState, ), STT.EndState),                                     # EndState
                           STEntryDef(CBB.CodeBlock1, (STT.StartState, STT.State1, STT.State2), -1),                       # StartState
                           STEntryDef(CBB.CodeBlock3, (STT.StartState, STT.State2, STT.State3, STT.State1), STT.EndState), # State1
                           STEntryDef(CBB.CodeBlock2, (STT.State3, ), -1),                                                 # State2
                           STEntryDef(CBB.CodeBlock3, (STT.State1, STT.State2), STT.State3))                               # State3
        self.ST = STT  # Used to allow access outside of __init__
        
        self.StateNames = ('EndState',
                           'StartState',
                           'State1',
                           'State2',
                           'State3')
        
    
      def GetCodeBlockName(self, CBIndex):
        return self.CB(self.CodeBlockTable[CBIndex].CBIndx).name
      
      def GetStateName(self, SNIndex):
        return self.StateNames[SNIndex]
    
      CodeBlock1 = '''
    self.StateRValue = random.randint(0, 2)
    '''
    
      CodeBlock2 = '''
    self.StateRValue = random.randint(0, 0)
    '''
    
      CodeBlock3 = '''
    self.StateRValue = random.randint(0, 4)
    '''
    
      EndMachine = '''
    self.StateRValue = random.randint(0, 9)
    '''
    
    if __name__ == "__main__":
      StateMachine = CStateMachinePy(TraceFile = sys.stdout, FriendlyTrace = True)
      CaptureTimer = CCaptureTimer()
      rvalue = 0
      
      print("-" * 50)
      for count in range(0, 10):
        with CCodeTimer("StateRun", CaptureTimer):
          rvalue = StateMachine.Run()
      
        print("\nState machine ended with ({0})".format(rvalue))
        print("State machine states processed ({0})".format(StateMachine.StatesProcessed))
        print("State machine duration ({0}ms)".format(CaptureTimer.Took))
        print("-" * 50)
      
      exit(0)
  
  EXAMPLE2
    This is the recommended method, because of issues with the python 'compile' statement.
    If you have lots of one to 5 liners, these should not give it a problem.  You can 
    make this strings and not use a method.  You can intermix them also.  I.E., on code
    block can be inline and one can be a method.
    
    See 'CodeBlock1'.  It does not use a method, its in line code.  Just remember that
    if the block gets to large, it might cause issues.  One of the issues I came across
    what 'self' was not known.  Very strange.
    
    import random # pylint: disable=unused-import
    import sys
    import os
    from enum import IntEnum
    
    from Libs.Base.CodeTimer import (CCodeTimer, CCaptureTimer)
    from Libs.Base.CreationInfo import CCreationInfo
    from Libs.StateMachine import (CodeBlockEntryDef as CBEntryDef,   # pylint: disable=unused-import
                                   CStateMachine,
                                   StateTableEntryDef as STEntryDef,
                                   StateMachineError)
    
    class CStateMachinePy(CStateMachine):
    
      def __init__(self, TraceFile = None, FriendlyTrace = False):
        CStateMachine.__init__(self, TraceFile, FriendlyTrace)
        self.StateRValue = -1
        
          # You must capture the globals and locals for the exec
          # If you wish to control the exec you can set this to what you
          # wish the block of code to have access to.
        self.Globals = globals()
        self.Locals = locals()    
    
          # Get our module name    
        MFName = os.path.basename(CCreationInfo().CreationFile)
        
        class CBB(IntEnum):
          CodeBlock1 = 0
          CodeBlock2 = 1
          CodeBlock3 = 2
          EndMachine = 3
    
        self.CodeBlockTable = (CBEntryDef(CBB.CodeBlock1, compile(self.CodeBlock1, MFName, "exec")),
                               CBEntryDef(CBB.CodeBlock2, compile(self.__CodeBlock2__, MFName, "exec")),
                               CBEntryDef(CBB.CodeBlock3, compile(self.__CodeBlock3__, MFName, "exec")),
                               CBEntryDef(CBB.EndMachine, compile(self.__EndMachine__, MFName, "exec")))
        self.CB = CBB # Used to allow access outside of __init__
        
        self.StartState = 1
        self.EndState = 0
        class STT(IntEnum):
          EndState = 0
          StartState = 1
          State1 = 2
          State2 = 3
          State3 = 4
    
        self.StateTable = (STEntryDef(CBB.EndMachine, (STT.EndState, ), STT.EndState),                                     # EndState
                           STEntryDef(CBB.CodeBlock1, (STT.StartState, STT.State1, STT.State2), -1),                       # StartState
                           STEntryDef(CBB.CodeBlock3, (STT.StartState, STT.State2, STT.State3, STT.State1), STT.EndState), # State1
                           STEntryDef(CBB.CodeBlock2, (STT.State3, ), -1),                                                 # State2
                           STEntryDef(CBB.CodeBlock3, (STT.State1, STT.State2), STT.State3))                               # State3
        self.ST = STT  # Used to allow access outside of __init__
        
        self.StateNames = ('EndState',
                           'StartState',
                           'State1',
                           'State2',
                           'State3')
        
    
      def GetCodeBlockName(self, CBIndex):
        return self.CB(self.CodeBlockTable[CBIndex].CBIndx).name
      
      def GetStateName(self, SNIndex):
        return self.StateNames[SNIndex]
    
      def CodeBlock2(self):
        self.StateRValue = random.randint(0, 0)
    
      def CodeBlock3(self):
        self.StateRValue = random.randint(0, 4)
      
      def EndMachine(self):
        self.StateRValue = random.randint(0, 9)
        
      CodeBlock1 = '''
    self.StateRValue = random.randint(0, 2)
    '''
    
      __CodeBlock2__ = 'self.CodeBlock2()'
    
      __CodeBlock3__ = 'self.CodeBlock3()'
    
      __EndMachine__ = 'self.StateRValue = random.randint(0, 9)'
    
    if __name__ == "__main__":
      StateMachine = CStateMachinePy(TraceFile = sys.stdout, FriendlyTrace = True)
      CaptureTimer = CCaptureTimer()
      rvalue = 0
      
      print("-" * 50)
      for count in range(0, 10):
        with CCodeTimer("StateRun", CaptureTimer):
          rvalue = StateMachine.Run()
      
        print("\nState machine ended with ({0})".format(rvalue))
        print("State machine states processed ({0})".format(StateMachine.StatesProcessed))
        print("State machine duration ({0}ms)".format(CaptureTimer.Took))
        print("-" * 50)
      
      exit(0)
    
  EXAMPLE OUTPUT FOR BOTH EXAMPLES
    The output is a lot, so only part will be shown. In the friendly mode you get a lot
    of output.  See below.
    
      --------------------------------------------------
      State:             StartState
      State Entry:       (CodeBlock1, (StartState, State1, State2), -1)
      State RValue:      2
      Prev State:        -1
      Prev State Entry:  -1
      Prev State RValue: -1
      
      State:             State2
      State Entry:       (CodeBlock2, (State3, ), -1)
      State RValue:      0
      Prev State:        StartState
      Prev State Entry:  (CodeBlock1, (StartState, State1, State2), -1)
      Prev State RValue: 2
    
    In the Non-Friendly mode each trace is one line, thus works well for log files.  It is
    still a lot of data.  State machines run thru states like crazy.  See Below.
    
      --------------------------------------------------
      StartState, (CodeBlock1, (StartState, State1, State2), -1), 2 :: -1, -1, -1
      State2, (CodeBlock2, (State3, ), -1), 0 :: StartState, (CodeBlock1, (StartState, State1, State2), -1), 2
      State3, (CodeBlock3, (State1, State2), State3), 1 :: State2, (CodeBlock2, (State3, ), -1), 0
      State2, (CodeBlock2, (State3, ), -1), 0 :: State3, (CodeBlock3, (State1, State2), State3), 1
      State3, (CodeBlock3, (State1, State2), State3), 3 :: State2, (CodeBlock2, (State3, ), -1), 0
      
    As you can see the Non-Friendly mode is very compressed compared the Friendly mode.  
    The friendly mode is easer to read but makes very large log files.  Its also harder 
    to parse if you write something to parse the log files.  The None-Friendly is in 
    the same order as the Friendly mode.  Current State and Previous State information is
    separated by '::'.  If you wished to make our log file even more compressed you could
    override the 'TraceStates' method and only output the numbers.  But this is even harder
    to read.  You would have to write a program that converts all the numbers to text.  To
    do this your program would create an instance of the state machine, but do not call the
    'Run' method and then you can access all the tables so you can covert the number to 
    text.
