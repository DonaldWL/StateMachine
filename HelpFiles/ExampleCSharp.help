You can find this example at 'StateMachine/Examples/ExampleCSharp'.  The only 
directory that contains files is TPL.  

ExampleCSharp shows you how to create TPL files for the CSharp (C#) language.  
Below is a list of the files and what they are for.

  ExampleCSharp.cpp
    Main for the program
  StateMachine.cs
    This is the main class for the state machine
  StateMachineTables.cs
    Contains all the tables and variables that are generated for the 
    state machine.

All the examples have the same basic code style when it comes to accessing the
state table.  Python is a little different but all the others are the same.

All the code blocks are contained within a switch statement.  Each code block has 
it's own 'case' entry.  Every time you create a new code block for your state machine
you need to add a new 'case' entry.  

A enum is created with the code block names.  The names are CB_<your code block name>.
Each code block must set 'StateRValue' to an 'int' value.  This is then used in the
state machine to determine what state to transition to.  Below is a simple example of
a code block within the switch statement.  This is from the example

    // StateRValue
    //   0 -> Ok
    //   1 -> InFileDir does not exist
    //        OutFileDir does not exist
    //        InFileDir and OutFileDir are the same
  case (int) CSMT.CB.StartMachine:
    StateRValue = 0;
    InFileDir = Path.GetFullPath(InFileDir);
    Log("Info", "InFileDir set to ", InFileDir);
    OutFileDir = Path.GetFullPath(OutFileDir);
    Log("Info", "OutFileDir set to ", OutFileDir);
    if (!Directory.Exists(InFileDir)) {
      StateRValue = 1;
      ReturnValue.UserData = Log("Error", "InFileDir (", InFileDir, 
                                 ") does not exist or is not a directory");
      ReturnValue.UserRValue = URValue.InDirErr;
    }
    if (!Directory.Exists(OutFileDir)) {
      StateRValue = 1;
      ReturnValue.UserData = Log("Error", "OutFileDir (", OutFileDir, 
                                 ") does not exist or is not a directory");
      ReturnValue.UserRValue = URValue.OutDirErr;
    }
    if (InFileDir == OutFileDir) {
      StateRValue = 1;
      ReturnValue.UserData = Log("Error", "InFileDir (", InFileDir, 
                                 ") is the same as OutFileDir (", OutFileDir, ")");
      ReturnValue.UserRValue = URValue.InOutDirErr;
    }
    break;


This code block is used to setup the state machine for the users code.  Its
name does not matter, we just picked this to make it easer to understand what
its for.

Looking at the code you will see that it has two possible values for 'StateRValue'.
Your SMS file would define how it would transition using these values.  Below is
the SMS file entry for a state that uses this code block.

  @State StartState StartMachine
    0 -> GetFiles
    1 -> EndState

If 'StateRValue' is 0 then the next state will be 'GetFiles', if it is 1 then the next
state will be 'EndState'.

As you can see its not very complicated. to add states and code blocks.  Remember, 
a code block can be assigned to more than one state.  This is very common, the code
may be the same but the state of the program is not, thus you are executing the same
code but its results have a different meaning.

A good example of this would be to modify the SMS file to have a state for closing
the files on error and remove this from the end of the loop.  Thus, after the files
have been open any error would go to that state and that state could close the files
and then go to end stop instead of next file.

Most the tables you find in the StateMachineTable.h are for tracing.  The only table
that is used for the state machine is 'StateTable'.  This contains the code block to
execute for the state and all of its transition states.  Below is an example of an
entry.

  (int)CB.CloseFiles, (int)ST.CloseFiles, 3, 32, 21, 21, -1,   // 0 (NextFile, EndState, EndState), -1
  
The first item is the code block to execute in the switch statement.  The next is an index
into the 'StateNames' table, this is only for tracing.  The next '3', is how many transitions
are defined for this state.  This example has 3.  the 25, 14, and 14 are the transition states.
They are not really a state they are an index into 'StateTable' for that state.  If you have
an OtherWise define for you state the '-1' would be an index to that state.

Its not a very complicated table and is very fast.  So transitions are quick, most state machines
require this.

Some of the code in the state machine is keeping track of the previous state, this is not really
required and can be removed, I have it so if I wish I can use it in trace.  I would recommend
removing it for a real program.
